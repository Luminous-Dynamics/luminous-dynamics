#!/usr/bin/env node

/**
 * Automated Performance Fixes for Claude Code
 * Generated by performance diagnostic
 */

const fs = require('fs');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();

class PerformanceFixes {
  constructor() {
    this.timersToClean = [];
    this.connectionsToClose = [];
    this.fixes = 0;
  }

  async applyFixes() {
    console.log('üîß Applying automated performance fixes...');
    
    await this.cleanupDatabases();
    await this.optimizeDatabaseSettings();
    await this.createTimerRegistry();
    await this.setupGracefulShutdown();
    await this.addMemoryMonitoring();
    
    console.log("\1" + ${...} + "\2");
  }

  async cleanupDatabases() {
    console.log('üóÑÔ∏è  Cleaning up databases...');
    
    const dbPaths = [
      'the-weave/core/agent-comms-sqlite/agents.db',
      'the-weave/core/network/unified-agent-network.db'
    ];
    
    for (const dbPath of dbPaths) {
      const fullPath = path.join(process.cwd(), dbPath);
      if (fs.existsSync(fullPath)) {
        await this.cleanupDatabase(fullPath);
      }
    }
    
    this.fixes++;
  }

  async cleanupDatabase(dbPath) {
    return new Promise((resolve, reject) => {
      const db = new sqlite3.Database(dbPath);
      
      // Clean old messages (keep last 1000)
      db.run(`DELETE FROM messages WHERE id NOT IN (
        SELECT id FROM messages ORDER BY created_at DESC LIMIT 1000
      )`, (err) => {
        if (err && !err.message.includes('no such table')) {
          console.log("\1" + ${...} + "\2");
        }
      });
      
      // Clean old unified_messages 
      db.run(`DELETE FROM unified_messages WHERE id NOT IN (
        SELECT id FROM unified_messages ORDER BY created_at DESC LIMIT 1000
      )`, (err) => {
        if (err && !err.message.includes('no such table')) {
          console.log("\1" + ${...} + "\2");
        }
      });
      
      // Vacuum to reclaim space
      db.run('VACUUM', (err) => {
        if (err) {
          console.log("\1" + ${...} + "\2");
        }
        db.close(resolve);
      });
    });
  }

  async optimizeDatabaseSettings() {
    console.log('‚ö° Optimizing database settings...');
    
    // Create database optimization patch
    const optimizationPatch = `
// Add this to your database initialization
db.run('PRAGMA journal_mode = WAL');
db.run('PRAGMA synchronous = NORMAL');
db.run('PRAGMA cache_size = 10000');
db.run('PRAGMA temp_store = MEMORY');
`;
    
    fs.writeFileSync('database-optimization.js', optimizationPatch);
    console.log('  Created database-optimization.js');
    this.fixes++;
  }

  async createTimerRegistry() {
    console.log('‚è∞ Creating timer registry...');
    
    const timerRegistry = `
class TimerRegistry {
  constructor() {
    this.timers = new Set();
    this.intervals = new Set();
  }

  setTimeout(callback, delay, ...args) {
    const timer = setTimeout(() => {
      this.timers.delete(timer);
      callback(...args);
    }, delay);
    this.timers.add(timer);
    return timer;
  }

  setInterval(callback, delay, ...args) {
    const interval = setInterval(callback, delay, ...args);
    this.intervals.add(interval);
    return interval;
  }

  clearTimeout(timer) {
    clearTimeout(timer);
    this.timers.delete(timer);
  }

  clearInterval(interval) {
    clearInterval(interval);
    this.intervals.delete(interval);
  }

  clearAll() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.intervals.forEach(interval => clearInterval(interval));
    this.timers.clear();
    this.intervals.clear();
  }
}

module.exports = new TimerRegistry();
`;
    
    fs.writeFileSync('timer-registry.js', timerRegistry);
    console.log('  Created timer-registry.js');
    this.fixes++;
  }

  async setupGracefulShutdown() {
    console.log('üõë Setting up graceful shutdown...');
    
    const shutdownScript = `
const timerRegistry = require('./timer-registry');

class GracefulShutdown {
  constructor() {
    this.cleanupHandlers = [];
    this.setupHandlers();
  }

  addCleanupHandler(handler) {
    this.cleanupHandlers.push(handler);
  }

  setupHandlers() {
    ['SIGINT', 'SIGTERM', 'exit'].forEach(signal => {
      process.on(signal, async () => {
        console.log('\\nüõë Graceful shutdown triggered by ' + signal);
        
        // Clear all timers
        timerRegistry.clearAll();
        
        // Run cleanup handlers
        for (const handler of this.cleanupHandlers) {
          try {
            await handler();
          } catch (error) {
            console.error('Cleanup handler failed:', error);
          }
        }
        
        console.log('‚úÖ Graceful shutdown complete');
        process.exit(0);
      });
    });
  }
}

module.exports = new GracefulShutdown();
`;
    
    fs.writeFileSync('graceful-shutdown.js', shutdownScript);
    console.log('  Created graceful-shutdown.js');
    this.fixes++;
  }

  async addMemoryMonitoring() {
    console.log('üìä Adding memory monitoring...');
    
    const memoryMonitor = `
class MemoryMonitor {
  constructor(options = {}) {
    this.interval = options.interval || 30000; // 30 seconds
    this.threshold = options.threshold || 200; // 200MB
    this.monitoring = false;
  }

  start() {
    if (this.monitoring) return;
    
    this.monitoring = true;
    console.log('üìä Memory monitoring started');
    
    this.monitorInterval = setInterval(() => {
      const usage = process.memoryUsage();
      const heapUsedMB = Math.round(usage.heapUsed / 1024 / 1024);
      
      if (heapUsedMB > this.threshold) {
        console.warn('‚ö†Ô∏è  High memory usage: ' + heapUsedMB + 'MB');
        
        if (global.gc) {
          global.gc();
          console.log('‚ôªÔ∏è  Garbage collection triggered');
        }
      }
    }, this.interval);
  }

  stop() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitoring = false;
      console.log('üìä Memory monitoring stopped');
    }
  }
}

module.exports = MemoryMonitor;
`;
    
    fs.writeFileSync('memory-monitor.js', memoryMonitor);
    console.log('  Created memory-monitor.js');
    this.fixes++;
  }
}

// Run fixes if script is called directly
if (require.main === module) {
  const fixes = new PerformanceFixes();
  fixes.applyFixes().catch(console.error);
}

module.exports = PerformanceFixes;
